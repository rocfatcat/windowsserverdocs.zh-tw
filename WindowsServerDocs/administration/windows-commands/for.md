---
title: 對象
description: For 命令的參考文章，它會在一組檔案內針對每個檔案執行指定的命令。
ms.topic: reference
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
ms.author: lizross
author: eross-msft
manager: mtillman
ms.date: 10/16/2017
ms.openlocfilehash: a7cb7d2882a0af886ead2a74de5b56c00302e589
ms.sourcegitcommit: db2d46842c68813d043738d6523f13d8454fc972
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/10/2020
ms.locfileid: "89634832"
---
# <a name="for"></a>對象

針對每個檔案，在一組檔案內執行指定的命令。

## <a name="syntax"></a>語法

```
for {%% | %}<variable> in (<set>) do <command> [<commandlineoptions>]
```

### <a name="parameters"></a>參數

| 參數 | 描述 |
| --------- | ----------- |
| `{%% | %}<variable>` | 必要。 代表可取代的參數。 使用單一的% sign (`%`) ，在命令提示字元中執行 **for** 命令。 使用雙百分比符號 (`%%`) 來執行批次檔中的 **for** 命令。 變數會區分大小寫，而且必須以字母值（例如 **% a**、 **% b**或 **% c**）來表示。 |
| (`<set>`) | 必要。 指定一或多個檔案、目錄或文字字串，或是要執行命令的值範圍。 它必須用括號括住。 |
| `<command>` | 必要。 指定您要在每個檔案、目錄或文字字串上執行的命令，或包含在 *set*內的值範圍。 |
| `<commandlineoptions>` | 指定您想要搭配指定命令使用的任何命令列選項。 |
| /? | 在命令提示字元顯示說明。 |

#### <a name="remarks"></a>備註

- 您可以在批次檔中，或直接從命令提示字元使用這個命令。

- 下列屬性適用于 **for** 命令：

  - 此命令會將或取代為 `% variable` `%% variable` 指定之集合中的每個文字字串，直到指定的命令處理所有檔案為止。

  - 變數名稱會區分大小寫、全域，且不能超過52一次都可以啟用。

  - 為了避免與批次參數混淆， `%0` `%9` 您可以使用任何字元做為 *變數* ，但數位 **0** 到 **9**除外。 針對簡單的批次檔，像這樣的單一字元 `%%f` 都可以運作。

  - 您可以針對複雜批次檔中的 *變數* 使用多個值，以區別不同的可取代變數。

- *Set*參數可以代表一組檔案或數個檔案群組。 您可以使用萬用字元 (**&#42;** 和 **？**) 指定檔案集。 以下是有效的檔集：

  ```
  (*.doc)
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```

- 當您使用此命令時， *set* 中的第一個值會取代 `% variable` or `%% variable` ，然後指定的命令會處理此值。 這會繼續進行，直到處理與 *設定* 值對應的所有檔案 (或群組) 為止。

- **在和中****不**是參數，但您必須使用此命令。 如果您省略其中一個關鍵字，則會顯示錯誤訊息。

- 如果已啟用命令延伸 (預設) ，則支援 **下列的其他** 表單：

  - **僅限目錄：** 如果 *設定* 包含萬用字元 (**&#42;** 或 **？**) ，則會針對每個 (目錄執行指定的 *命令* ，而不是指定之目錄) 中符合 *集合*的一組檔案。 語法為：

    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```

  - **遞迴：** 帶領根目錄位於 *drive*：*path* 的目錄樹狀結構，並在樹狀目錄的每個目錄中執行 **for** 語句。 如果在 **/r**之後未指定任何目錄，則會使用目前的目錄做為根目錄。 如果 *set* 只是單一期間 ( ) ，它只會列舉目錄樹狀結構。 語法為：

    ```
    for /r [[<drive>:]<path>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    ```

  - **反覆運算值範圍：** 您可以使用反復變數來設定起始值 (*開始*# ) ，然後逐步執行設定的值範圍，直到值超過設定結束值 (*end*# ) 為止。 **/l** 將藉由比較 *開始*# 與 *end*# 來執行反復進行。 如果 *start*# 小於命令的 *結尾*，則會執行命令。 當反復變數超過 end # 時，命令 shell 會 *結束*迴圈。 您也可以使用負面的 *步驟*#，逐步執行遞減值的範圍。 例如， (1，1，5) 會產生序列 1 2 3 4 5， (5，-1，1) 會產生序列 5 4 3 2 1。 語法為：

    ```
    for /l {%%|%}<variable> in (<start#>,<step#>,<end#>) do <command> [<commandlinepptions>]
    ```

  - **反覆運算和檔案剖析：** 使用檔案剖析來處理命令輸出、字串和檔案內容。 使用反復變數來定義您想要檢查的內容或字串，並使用各種 *parsingkeywords* 選項來進一步修改剖析。  使用 *parsingkeywords* token 選項來指定應以反復變數形式傳遞的權杖。 請注意，使用時若未使用 token 選項， **/f** 將只會檢查第一個 token。

    檔案剖析包含讀取輸出、字串或檔案內容，然後將它細分為個別的文字行，並將每一行剖析為零或多個標記。 接著會呼叫 **for** 迴圈，並將反復變數值設定為 token。 根據預設， **/f** 會從每個檔案的每一行傳遞第一個空白的分隔標記。 會略過空白行。

    語法如下：

    ```
    for /f [<parsingkeywords>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in (<literalstring>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in ('<command>') do <command> [<commandlinepptions>]
    ```

    *Set*引數會指定一或多個檔案名。 每個檔案在移至 *set*中的下一個檔案之前，都會先開啟、讀取和處理。 若要覆寫預設剖析行為，請指定 *parsingkeywords*。 這是加上引號的字串，其中包含一個或多個關鍵字，以指定不同的剖析選項。

    如果您使用 **usebackq** 選項，請使用下列其中一個語法：

    ```
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (<Set>) do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in ('<LiteralString>') do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (`<command>`) do <command> [<commandlinepptions>]
    ```

    下表列出可用於 *parsingkeywords*的剖析關鍵字。

    | 關鍵字 | 描述 |
    | ------- | ----------- |
    | eol =`<c>` | 指定只 (一個字元) 的行字元結尾。 |
    | skip =`<n>` | 指定要在檔開頭略過的行數。 |
    | delims =`<xxx>` | 指定分隔符號集。 這會取代空格和 tab 的預設分隔符號集。 |
    | 標記 =`<x,y,m–n>` | 指定要將每一行的哪些 token 傳遞給每個反復專案的 **for** 迴圈。 因此，會配置其他變數名稱。 *m-n* 指定範圍，從 *m*到第 *n*個標記。 如果 token **=** string 中的最後一個字元是星號 (**&#42;**) ，則會配置額外的變數，並在剖析的最後一個 token 之後，接收該行的其餘文字。 |
    | usebackq | 指定要以命令的形式執行帶引號的字串、使用單引號字串做為常值字串，或者，針對包含空格的長檔名，允許中的檔案名，並以 `<set>` 雙引號括住每個名稱。 |

  - **變數替代：** 下表 **列出) 的** 任何變數的選擇性語法 (：

    | 具有修飾詞的變數 | 描述 |
    | ---------------------- | ----------- |
    |` %~I` | 展開 `%I` 以移除任何周圍的引號。 |
    | `%~fI `| 展開 `%I` 至完整路徑名稱。 |
    | `%~dI `| 只會展開 `%I` 為磁碟機號。 |
    | `%~pI` | `%I`只展開至路徑。 |
    | `%~nI `| `%I`只展開至檔案名。 |
    | `%~xI` | 只會擴充 `%I` 至副檔名的副檔名。 |
    | `%~sI` | 展開路徑以只包含簡短名稱。 |
    | `%~aI` | 展開 `%I` 至檔案的檔案屬性。 |
    | `%~tI` | 展開 `%I` 至檔案的日期和時間。 |
    | `%~zI` | 展開 `%I` 至檔案的大小。 |
    | `%~$PATH:I` | 搜尋 PATH 環境變數中所列的目錄，並展開 `%I` 至第一個找到的目錄的完整名稱。 如果未定義環境變數名稱，或搜尋中找不到該檔案，此修飾詞會展開為空字串。 |

    下表列出您可以用來取得複合結果的修飾片語合。

    | 具有合併修飾詞的變數 | 描述 |
    | -------------------------------- | ----------- |
    | `%~dpI `| 只會展開 `%I` 為磁碟機號和路徑。 |
    | `%~nxI` | 只會擴充 `%I` 至檔案名和副檔名。 |
    | `%~fsI` | 只會展開 `%I` 為具有簡短名稱的完整路徑名稱。 |
    | `%~dp$PATH:I` | 搜尋 PATH 環境變數中所列的目錄， `%I` 並展開至第一個找到的磁碟機號和路徑。 |
    | `%~ftzaI` | 展開 `%I` 至類似 **dir**的輸出行。 |

    在上述範例中，您可以 `%I` 使用其他有效值來取代和路徑。 有效 **的** 變數名稱會結束 **%~** 語法。

    藉由使用大寫變數名稱 `%I` ，例如，您可以讓程式碼更容易閱讀，並避免與修飾詞混淆（不區分大小寫）。

- **剖析字串：** 您可以在 `for /f` 立即字串上使用剖析邏輯，方法是以雙引號括住 `<literalstring>` ：雙引號 (*不*usebackq) 或以單引號括*with*住 (Usebackq) --例如 (MyString) 或 ( ' MyString ' ) 。 `<literalstring>` 會被視為來自檔案的單一輸入行。 `<literalstring>`以雙引號剖析時，命令符號 (例如， `\ & | > < ^`) 會被視為一般字元。

- **剖析輸出：** 您可以使用 `for /f` 命令來剖析命令的輸出，方法是在括弧之間放置反向引號 `<command>` 。 它會被視為命令列，它會傳遞給子 Cmd.exe。 輸出會被捕獲到記憶體中，並剖析為檔案。

## <a name="examples"></a>範例

若要 **在批次處理** 檔中使用，請使用下列語法：

```
for {%%|%}<variable> in (<set>) do <command> [<commandlineoptions>]
```

若要使用可取代的變數 **% f**來顯示目前目錄中副檔名為 .doc 或 .txt 的所有檔案內容，請輸入：

```
for %f in (*.doc *.txt) do type %f
```

在上述範例中，在目前的目錄中具有 .doc 或 .txt 副檔名的每個檔案都會替代 **% f** 變數，直到顯示每個檔案的內容為止。 若要在批次檔中使用此命令，請將每個出現的 **% f** 取代為 **%% f**。 否則會忽略變數，並顯示錯誤訊息。

若要剖析檔案並忽略批註行，請輸入：

```
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
```

此命令會剖析 *myfile.txt*中的每一行。 它會忽略以分號開頭的行，並將每一行的第二和第三個 token 傳遞給 **for** 主體 (權杖是以逗號或空格) 分隔。 **For**語句的主體參考 **% i**以取得第二個 token， **% j**用來取得第三個 token，% **k**則會取得所有剩餘的權杖。 如果您所提供的檔案名包含空格，請使用引號括住文字 (例如，) 的檔案名。 若要使用引號，您必須使用 **usebackq**。 否則，會將引號解釋為定義要剖析的常值字串。

**% i** 明確宣告于 **for** 語句中。 **% j** 和 **% k** 是使用 token **=** 來隱含宣告。 您可以使用 token **=** 來指定最多26個權杖，但前提是它不會嘗試宣告大於字母 Z 或 z 的變數。

若要在括弧之間放置 *set* 來剖析命令的輸出，請輸入：

```
for /f usebackq delims== %i in ('set') do @echo %i
```

## <a name="additional-references"></a>其他參考資料

- [命令列語法關鍵](command-line-syntax-key.md)
