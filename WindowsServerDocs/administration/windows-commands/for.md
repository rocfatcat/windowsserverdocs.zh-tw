---
title: 對象
description: For 命令的參考主題，它會針對一組檔案中的每個檔案執行指定的命令。
ms.prod: windows-server
ms.technology: manage-windows-commands
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: 24ef5bc159e67862d419bd2728b14585f8b095d4
ms.sourcegitcommit: bf887504703337f8ad685d778124f65fe8c3dc13
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/16/2020
ms.locfileid: "83437013"
---
# <a name="for"></a>對象

針對每個檔案，在一組檔案中執行指定的命令。

## <a name="syntax"></a>語法

```
for {%% | %}<variable> in (<set>) do <command> [<commandlineoptions>]
```

### <a name="parameters"></a>參數

| 參數 | 說明 |
| --------- | ----------- |
| `{%% | %}<variable>` | 必要。 表示可取代的參數。 使用單一百分比符號（ `%` ），在命令提示字元中執行**for**命令。 使用雙百分比符號（ `%%` ）來執行批次檔中的**for**命令。 變數會區分大小寫，而且必須以字母值表示，例如 **% a**、 **% b**或 **% c**。 |
| (`<set>`) | 必要。 指定一或多個檔案、目錄或文字字串，或要在其上執行命令的值範圍。 它必須用括號括住。 |
| `<command>` | 必要。 指定您想要在每個檔案、目錄或文字字串上執行的命令，或是包含在*set*中的值範圍。 |
| `<commandlineoptions>` | 指定您想要與指定的命令搭配使用的任何命令列選項。 |
| /? | 在命令提示字元顯示說明。 |

#### <a name="remarks"></a>備註

- 您可以在批次檔中或直接從命令提示字元中使用此命令。

- 下列屬性適用于**for**命令：

  - 此命令會將或取代為 `% variable` `%% variable` 指定集合中的每個文字字串，直到指定的命令處理所有檔案為止。

  - 變數名稱會區分大小寫、全域，而且一次不能超過52。

  - 為了避免與批次參數混淆， `%0` 透過 `%9` ，您可以針對*變數*使用任何字元，但數位**0**到**9**除外。 對於簡單的批次檔，之類的單一字元 `%%f` 將會作用。

  - 您可以在複雜的批次檔中，針對*變數*使用多個值來區別不同的可取代變數。

- *Set*參數可以代表一組檔案或數個檔案群組。 您可以使用萬用字元（**&#42;** 和 **？**）來指定檔案集。 以下是有效的檔案集：

  ```
  (*.doc)
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```

- 當您使用此命令時， *set*中的第一個值會取代 `% variable` 或 `%% variable` ，然後指定的命令會處理此值。 這會繼續進行，直到處理對應至*集合*值的所有檔案（或檔案群組）為止。

- 和**中的****不**是參數，但您必須在此命令中使用它們。 如果您省略上述任一關鍵字，就會出現錯誤訊息。

- 如果已啟用命令延伸模組（這是預設值），則支援下列其他**形式的：**

  - **僅限目錄：** 如果*set*包含萬用字元（**&#42;** 或 **？**），則會針對每個目錄（而不是指定目錄中的一組檔案）執行指定的*命令*，以符合*集合*。 語法為：

    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```

  - **遞迴：** 會引導根目錄為*drive*：*path*的目錄樹狀結構，並在樹狀結構的每個目錄中執行**for**語句。 如果在 **/r**之後未指定任何目錄，則會使用目前的目錄做為根目錄。 如果*set*只是單一句點（.），它只會列舉目錄樹狀結構。 語法為：

    ```
    for /r [[<drive>:]<path>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    ```

  - 逐一查看**值的範圍：** 使用反復變數來設定起始值（*開始*#），然後逐步執行一組值的範圍，直到值超過設定結束值（*end*#）為止。 **/l**會比較*start*# 與*end*# 來執行反復項。 如果*start*# 小於*end*#，則會執行命令。 當反復變數超過 end # 時，命令 shell 會*結束*迴圈。 您也可以使用負*步驟*# 來逐步執行遞減值的範圍。 例如，（1，1，5）會產生序列 1 2 3 4 5，而（5，-1，1）會產生序列 5 4 3 2 1。 語法為：

    ```
    for /l {%%|%}<variable> in (<start#>,<step#>,<end#>) do <command> [<commandlinepptions>]
    ```

  - **反覆運算和檔案剖析：** 使用檔案剖析來處理命令輸出、字串和檔案內容。 使用反復變數來定義您想要檢查的內容或字串，並使用各種*parsingkeywords*選項進一步修改剖析。  使用 [ *parsingkeywords* token] 選項來指定應該將哪些權杖當做反復變數傳遞。 請注意，使用時若沒有 token 選項， **/f**將只會檢查第一個權杖。

    檔案剖析包含讀取輸出、字串或檔案內容，然後將其細分為個別的文字行，並將每一行剖析成零個或多個權杖。 然後，會使用設定為權杖的反復變數值來呼叫**for**迴圈。 根據預設， **/f**會從每個檔案的每一行傳遞第一個空白分隔的 token。 會略過空白行。

    語法如下：

    ```
    for /f [<parsingkeywords>] {%%|%}<variable> in (<set>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in (<literalstring>) do <command> [<commandlinepptions>]
    for /f [<parsingkeywords>] {%%|%}<variable> in ('<command>') do <command> [<commandlinepptions>]
    ```

    *Set*引數會指定一個或多個檔案名。 在移至*集合*中的下一個檔案之前，會先開啟、讀取和處理每個檔案。 若要覆寫預設剖析行為，請指定*parsingkeywords*。 這是加上引號的字串，其中包含一或多個用來指定不同剖析選項的關鍵字。

    如果您使用**usebackq**選項，請使用下列其中一個語法：

    ```
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (<Set>) do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in ('<LiteralString>') do <command> [<commandlinepptions>]
    for /f [usebackq <parsingkeywords>] {%%|%}<variable> in (`<command>`) do <command> [<commandlinepptions>]
    ```

    下表列出您可以用於*parsingkeywords*的剖析關鍵字。

    | 關鍵字 | 描述 |
    | ------- | ----------- |
    | eol =`<c>` | 指定行號的結尾（只需一個字元）。 |
    | skip =`<n>` | 指定要在檔案開頭略過的行數。 |
    | delims =`<xxx>` | 指定分隔符號集。 這會取代空格和索引標籤的預設分隔符號集。 |
    | 標記 =`<x,y,m–n>` | 指定每個反復專案要傳遞至**for**迴圈的每一行 token。 因此，系統會配置額外的變數名稱。 *m-n*指定範圍，從*m*到第*n*個權杖。 如果 token **=** 字串中的最後一個字元是星號（**&#42;**），則會配置額外的變數，而且它會在剖析的最後一個標記之後的那一行接收其餘文字。 |
    | usebackq | 指定要執行一個加上引號的字串做為命令、使用單引號的字串做為常值字串，或者，對於包含空格、允許中檔案名的長檔名， `<set>` 每個都以雙引號括住。 |

  - **變數替代：** 下表列出選擇性語法（適用于任何變數**I**）：

    | 具有修飾詞的變數 | 描述 |
    | ---------------------- | ----------- |
    |` %~I` | 展開 `%I` 以移除任何前後的引號。 |
    | `%~fI `| 展開 `%I` 為完整路徑名稱。 |
    | `%~dI `| 只會展開 `%I` 為磁碟機號。 |
    | `%~pI` | 只會展開 `%I` 至路徑。 |
    | `%~nI `| 只會展開 `%I` 為檔案名。 |
    | `%~xI` | `%I`僅擴充至副檔名。 |
    | `%~sI` | 將路徑展開為僅包含簡短名稱。 |
    | `%~aI` | 展開 `%I` 至檔案的檔案屬性。 |
    | `%~tI` | 會展開 `%I` 至檔案的日期和時間。 |
    | `%~zI` | 展開 `%I` 至檔案大小。 |
    | `%~$PATH:I` | 搜尋 PATH 環境變數中所列的目錄，並展開 `%I` 至第一個找到的目錄之完整名稱。 如果環境變數名稱未定義，或搜尋找不到檔案，則此修飾詞會展開為空字串。 |

    下表列出您可以用來取得複合結果的輔助按鍵組合。

    | 具有結合修飾詞的變數 | 描述 |
    | -------------------------------- | ----------- |
    | `%~dpI `| 只會展開 `%I` 為磁碟機號和路徑。 |
    | `%~nxI` | 只會展開 `%I` 至檔案名和副檔名。 |
    | `%~fsI` | 會展開 `%I` 為僅含簡短名稱的完整路徑名稱。 |
    | `%~dp$PATH:I` | 搜尋 PATH 環境變數中所列的目錄，並將其 `%I` 展開為第一個找到的磁碟機號和路徑。 |
    | `%~ftzaI` | 展開 `%I` 為類似**dir**的輸出行。 |

    在上述範例中，您可以 `%I` 使用其他有效的值來取代和路徑。 **對變數名稱**有效的會結束 **%~** 語法。

    藉由使用大寫的變數名稱（例如 `%I` ），您可以讓程式碼更容易閱讀，並避免與不區分大小寫的修飾詞混淆。

- **剖析字串：** 您可以使用 `for /f` 直接字串的剖析邏輯，方法是 `<literalstring>` 以雙引號（*不含*usebackq）或單引號（*含*usebackq）括住，例如（MyString）或（' MyString '）。 `<literalstring>`會被視為來自檔案的一行輸入。 `<literalstring>`在以雙引號剖析時，會將命令符號（例如 `\ & | > < ^` ）視為一般字元。

- **剖析輸出：** 您可以使用 `for /f` 命令來剖析命令的輸出，方法是在括弧之間放上引號 `<command>` 。 它會被視為命令列，它會傳遞至子 Cmd.exe。 輸出會捕獲到記憶體中，並剖析成檔案。

## <a name="examples"></a>範例

若要在批次處理**檔中使用，請**使用下列語法：

```
for {%%|%}<variable> in (<set>) do <command> [<commandlineoptions>]
```

若要使用可取代的變數 **% f**，顯示目前目錄中副檔名為 .doc 或 .txt 的所有檔案的內容，請輸入：

```
for %f in (*.doc *.txt) do type %f
```

在上述範例中，目前目錄中具有 .doc 或 .txt 副檔名的每個檔案都會取代 **% f**變數，直到每個檔案的內容顯示為止。 若要在批次檔中使用此命令，請以 **%% f**取代每個出現的 **% f** 。 否則，系統會忽略變數並顯示錯誤訊息。

若要剖析檔案，忽略批註行，請輸入：

```
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
```

此命令會剖析*myfile.txt*中的每一行。 它會忽略以分號開頭的行，並將每一行的第二個和第三個 token 傳遞至**for**主體（標記會以逗號或空格分隔）。 **For**語句的主體會參考 **% i**來取得第二個 token， **% j**以取得第三個 token，而 **% k**則用來取得所有剩餘的權杖。 如果您提供的檔案名包含空格，請使用引號括住文字（例如，檔案名）。 若要使用引號，您必須使用**usebackq**。 否則，引號會被視為定義要剖析的常值字串。

**% i**是在**for**語句中明確宣告的。 **% j**和 **% k**是使用 token **=** 來隱含宣告。 您可以使用 token **=** 來指定最多26個權杖，但前提是它不會嘗試宣告高於字母 Z 或 z 的變數。

若要藉由在括弧之間放置*設定*來剖析命令的輸出，請輸入：

```
for /f usebackq delims== %i in ('set') do @echo %i
```

## <a name="additional-references"></a>其他參考

- [命令列語法關鍵](command-line-syntax-key.md)
