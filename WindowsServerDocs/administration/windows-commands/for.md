---
title: 作為
description: '\* * * * 的 Windows 命令主題'
ms.prod: windows-server
ms.technology: manage-windows-commands
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: e7040e4cb8e0f38e58ce5e868535dcfb2d897fbd
ms.sourcegitcommit: b00d7c8968c4adc8f699dbee694afe6ed36bc9de
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/08/2020
ms.locfileid: "80844531"
---
# <a name="for"></a>作為



針對一組檔案中的每個檔案執行指定的命令。

如需如何使用此命令的範例，請參閱[範例](#BKMK_examples)。

## <a name="syntax"></a>語法

```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```

### <a name="parameters"></a>參數

|參數|描述|
|---------|-----------|
|{%%\|%}\<變數 >|必要。 表示可取代的參數。 使用單一百分比符號（ **%** ），在命令提示字元中執行**for**命令。 使用雙百分比符號（ **%%** ）來執行批次檔中的**for**命令。 變數會區分大小寫，而且必須以字母值表示，例如 **% A**、 **% B**或 **% C**。|
|（\<設定 >）|必要。 指定一或多個檔案、目錄或文字字串，或要在其上執行命令的值範圍。 需要括弧。|
|\<命令 >|必要。 指定您想要在每個檔案、目錄或文字字串上執行的命令，或是包含在*Set*中的值範圍。|
|\<CommandLineOptions >|指定您想要與指定的命令搭配使用的任何命令列選項。|
|/?|在命令提示字元顯示說明。|

## <a name="remarks"></a>備註

- 使用**for**

  您可以在批次檔中或直接從命令提示字元使用**for**命令。
- 使用批次參數

  下列屬性適用于**for**命令：  
  - **For**命令會以指定集合中的每個文字字串取代 **%** <em>變數</em>或 **%%** <em>變數</em>，直到指定的命令處理所有檔案為止。
  - 變數名稱會區分大小寫、全域，而且一次不能超過52。
  - 若要避免與批次參數 **%0**到 **%9**混淆，您可以針對*變數*使用任何字元，但數位0到9除外。 若是簡單的批次檔， **%% f**之類的單一字元就會生效。
  - 您可以在複雜的批次檔中，針對*變數*使用多個值來區別不同的可取代變數。
- 指定檔案群組

  *Set*參數可以代表一組檔案或數個檔案群組。 您可以使用萬用字元（ **&#42;** 和 **？** ）來指定檔案集。 以下是有效的檔案集：  
  ```
  (*.doc) 
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```  
  當您使用**for**命令時， *Set*中的第一個值會取代 **%** <em>變數</em>或 **%%** <em>變數</em>，然後指定的命令會處理此值。 這會繼續進行，直到處理對應至*集合*值的所有檔案（或檔案群組）為止。
- 使用**in**和**do**關鍵字

  **In**和中**的不**是參數，但您必須將它們與**用於**。 如果您省略上述任一關鍵字，就會出現錯誤訊息。
- **針對**使用其他形式的

  如果已啟用命令延伸模組（這是預設值），則支援下列其他**形式的：**  
  - 僅限目錄

    如果*set*包含萬用字元 **&#42;** （或 **？** ），則會針對每個目錄（而不是指定目錄中的一組檔案）執行指定的*命令*，以符合*集合*。

    語法為：  
    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>] 
    ```  
  - Recursive

    會引導根目錄為*Drive*：*Path*的目錄樹狀結構，並在樹狀結構的每個目錄中執行**for**語句。 如果在 **/r**之後未指定任何目錄，則會使用目前的目錄做為根目錄。 如果*Set*只是單一句點（.），它只會列舉目錄樹狀結構。

    語法為：  
    ```
    for /r [[<Drive>:]<Path>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```  
  - 反覆運算某個範圍的值

    使用反復變數來設定起始值（*開始*#），然後逐步執行一組值的範圍，直到值超過設定結束值（*End*#）為止。 **/l**會比較*Start*# 與*End*# 來執行反復項。 如果*Start*# 小於*End*#，則會執行命令。 當反復變數超過 End # 時，命令 shell 會*結束*迴圈。 您也可以使用負*步驟*# 來逐步執行遞減值的範圍。 例如，（1，1，5）會產生序列 1 2 3 4 5，而（5，-1，1）會產生序列 5 4 3 2 1。

    語法為：  
    ```
    for /l {%%|%}<Variable> in (<Start#>,<Step#>,<End#>) do <Command> [<CommandLineOptions>]
    ```  
  - 反覆運算和檔案剖析

    使用檔案剖析來處理命令輸出、字串和檔案內容。  使用反復變數來定義您想要檢查的內容或字串，並使用各種*ParsingKeywords*選項進一步修改剖析。  使用 [ *ParsingKeywords* token] 選項來指定應該將哪些權杖當做反復變數傳遞。 請注意，使用時若沒有 token 選項， **/f**將只會檢查第一個權杖。

    檔案剖析包含讀取輸出、字串或檔案內容，然後將其細分為個別的文字行，並將每一行剖析成零個或多個權杖。 然後，會使用設定為權杖的反復變數值來呼叫**for**迴圈。 根據預設， **/f**會從每個檔案的每一行傳遞第一個空白分隔的 token。 會略過空白行。

    語法如下：  
    ```
    for /f [<ParsingKeywords>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    for /f [<ParsingKeywords>] {%%|%}<Variable> in (<LiteralString>) do <Command> [<CommandLineOptions>]
    for /f [<ParsingKeywords>] {%%|%}<Variable> in ('<Command>') do <Command> [<CommandLineOptions>]
    ```  
    *Set*引數會指定一個或多個檔案名。 在移至*集合*中的下一個檔案之前，會先開啟、讀取和處理每個檔案。 若要覆寫預設剖析行為，請指定*ParsingKeywords*。 這是加上引號的字串，其中包含一或多個用來指定不同剖析選項的關鍵字。

    如果您使用**usebackq**選項，請使用下列其中一個語法：  
    ```
    for /f [usebackq <ParsingKeywords>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    for /f [usebackq <ParsingKeywords>] {%%|%}<Variable> in ('<LiteralString>') do <Command> [<CommandLineOptions>]
    for /f [usebackq <ParsingKeywords>] {%%|%}<Variable> in (`<Command>`) do <Command> [<CommandLineOptions>]
    ```  
    下表列出您可以用於*ParsingKeywords*的剖析關鍵字。  

    |      關鍵字      |                                                                                                                                                                                                          描述                                                                                                                                                                                                          |
    |-------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    |     eol =\<c >      |                                                                                                                                                                                   指定行號的結尾（只需一個字元）。                                                                                                                                                                                    |
    |     skip =\<N >     |                                                                                                                                                                              指定要在檔案開頭略過的行數。                                                                                                                                                                              |
    |   delims =\<xxx >   |                                                                                                                                                                     指定分隔符號集。 這會取代空格和索引標籤的預設分隔符號集。                                                                                                                                                                      |
    | token =\<X，Y，M – N > | 指定每個反復專案要傳遞至**for**迴圈的每一行 token。 因此，系統會配置額外的變數名稱。 *M*–*N*指定範圍，從*M*到第*N*個權杖。 如果 token **=** 字串中的最後一個字元是星號（ **&#42;** ），則會配置額外的變數，而且它會在剖析的最後一個標記之後的那一行接收其餘文字。 |
    |     usebackq      |                                                                                             指定要：執行加上引號的字串做為命令、使用單引號括住的字串做為常值字串，或者，對於包含空格的長檔名，允許 *\<設定\>* 中的檔案名，每個都以雙引號括住。                                                                                              |


  - 變數替代

    下表列出選擇性語法（適用于任何變數**I**）。  

    |具有修飾詞的變數|描述|
    |----------------------|-----------|
    |% ~ I|展開 **% I** ，移除任何前後的引號（）。|
    |% ~ fI|將 **% I**展開為完整路徑名稱。|
    |% ~ dI|僅將 **% I**展開為磁碟機號。|
    |% ~ pI|將 **% I**展開為僅限路徑。|
    |% ~ nI|僅將 **% I**展開為檔案名。|
    |% ~ xI|僅將 **% I**展開為副檔名。|
    |% ~ sI|將路徑展開為僅包含簡短名稱。|
    |% ~ aI|將 **% I**展開至檔案的檔案屬性。|
    |% ~ tI|將 **% I**展開至檔案的日期和時間。|
    |% ~ zI|將 **% I**展開為檔案大小。|
    |% ~ $PATH： I|搜尋 PATH 環境變數中所列的目錄，並將 **% I**擴充到第一個找到的目錄之完整名稱。 如果環境變數名稱未定義，或搜尋找不到檔案，則此修飾詞會展開為空字串。|

    下表列出您可以用來取得複合結果的輔助按鍵組合。  

    |具有結合修飾詞的變數|描述|
    |--------------------------------|-----------|
    |% ~ dpI|將 **% I**展開為磁碟機號和路徑。|
    |% ~ nxI|僅將 **% I**擴充至檔案名和副檔名。|
    |% ~ Fsi.exe|將 **% I**展開為僅含簡短名稱的完整路徑名稱。|
    |% ~ dp $ 路徑： I|搜尋 **% I**的 PATH 環境變數中所列的目錄，並展開至第一個找到的磁碟機號和路徑。|
    |% ~ ftzaI|將 **% I**展開為類似**dir**的輸出行。|

    在上述範例中，您可以用其他有效的值取代 **% I**和 PATH。 **對**變數名稱有效的會終止 **%~** 語法。

    藉由使用大寫的變數名稱（例如 **% I**），您可以讓程式碼更容易閱讀，並避免與不區分大小寫的修飾詞混淆。
- 剖析字串

  您可以藉由將 *\<LiteralString\>* 包裝在任一：雙引號（*不含*usebackq）或單引號（*with* usebackq）---例如，（MyString）或（' MyString '），在立即字串上使用**for/f**剖析邏輯。 *\<LiteralString\>* 會視為檔案中的單一輸入行。 剖析以雙引號括住 *\<LiteralString\>* 時，會將命令符號（例如 **\\ \& \|** \> \< \^）視為一般字元。
- 剖析輸出

  您可以使用**for/f**命令來剖析命令的輸出，方法是將加上引號的 *\<命令*放在括弧之間\>。 它會被視為命令列，它會傳遞至子 Cmd.exe。 輸出會捕獲到記憶體中，並剖析成檔案。

## <a name="examples"></a><a name=BKMK_examples></a>典型

若要在批次處理**檔中使用，請**使用下列語法：
```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```
若要使用可取代的變數 **% f**，顯示目前目錄中副檔名為 .doc 或 .txt 的所有檔案的內容，請輸入：
```
for %f in (*.doc *.txt) do type %f 
```
在上述範例中，目前目錄中具有 .doc 或 .txt 副檔名的每個檔案都會取代 **% f**變數，直到每個檔案的內容顯示為止。 若要在批次檔中使用此命令，請以 **%% f**取代每個出現的 **% f** 。 否則，系統會忽略變數並顯示錯誤訊息。

若要剖析檔案，忽略批註行，請輸入：
```
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
```
此命令會剖析 Myfile.txt 中的每一行。 它會忽略以分號開頭的行，並將每一行的第二個和第三個 token 傳遞至**for**主體（標記會以逗號或空格分隔）。 **For**語句的主體會參考 **% i**來取得第二個 token， **% j**以取得第三個 token，而 **% k**則用來取得所有剩餘的權杖。 如果您提供的檔案名包含空格，請使用引號括住文字（例如，檔案名）。 若要使用引號，您必須使用**usebackq**。 否則，引號會被視為定義要剖析的常值字串。

**% i**是在**for**語句中明確宣告的。 **% j**和 **% k**是使用 token **=** 來隱含宣告。 您可以使用 token **=** 來指定最多26個權杖，但前提是它不會嘗試宣告高於字母 Z 或 z 的變數。

下列範例會列舉目前環境中的環境變數名稱。 若要藉由在括弧之間放置*設定*來剖析命令的輸出，請輸入：
```
for /f usebackq delims== %i in ('set') do @echo %i 
```

## <a name="additional-references"></a>其他參考資料

- [命令列語法關鍵](command-line-syntax-key.md)
